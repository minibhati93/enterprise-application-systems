```
enterprise-application-systems/
│
├── platform-decisions/
│ ├── choosing-a-frontend-framework.md
│ ├── when-angular-makes-sense.md
│ ├── when-react-makes-sense.md
│ └── longevity-vs-velocity.md
│
├── application-structure/
│ ├── monolith-vs-microfrontends.md
│ ├── feature-boundaries.md
│ ├── shared-libraries.md
│ └── deployment-models.md
│
├── state-management/
│ ├── local-vs-global-state.md
│ ├── when-to-introduce-state-management.md
│ ├── distributed-state-problems.md
│ └── state-and-team-ownership.md
│
├── integration-patterns/
│ ├── rest-vs-graphql.md
│ ├── graphql-at-scale.md
│ ├── frontend-bff-pattern.md
│ └── api-contract-evolution.md
│
├── performance-and-scale/
│ ├── performance-budgets.md
│ ├── runtime-vs-build-time.md
│ ├── frontend-observability.md
│ └── scaling-teams-vs-scaling-code.md
│
├── accessibility-and-i18n/
│ ├── accessibility-as-a-system-concern.md
│ ├── internationalization-strategies.md
│ └── compliance-and-realities.md
│
├── security-and-reliability/
│ ├── frontend-security-boundaries.md
│ ├── error-handling-strategies.md
│ └── resilience-in-ui-systems.md
│
└── published-articles/
├── dependency-injection-at-scale.md
├── monolith-vs-microfrontend-tradeoffs.md
└── graphql-in-enterprise-ui.md
```
